<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>User Portal - Delivery Tracking</title>
    
    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.min.css" />
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #f5f5f5;
            overflow: hidden;
        }
        
        html, body {
            height: 100%;
            width: 100%;
        }
        
        #map {
            position: fixed;
            top: 0;
            left: 0;
            height: 100vh;
            width: 100%;
            z-index: 1;
            background-color: #e8e8e8;
        }
        
        .leaflet-container {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        /* Panel Styling */
        #panel {
            position: fixed;
            bottom: 15px;
            left: 15px;
            background: white;
            padding: 18px;
            z-index: 1000;
            border: 1px solid #ddd;
            border-radius: 8px;
            font-size: 13px;
            width: 380px;
            max-height: 75vh;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            overflow-y: auto;
            animation: slideIn 0.3s ease-out;
        }
        
        @keyframes slideIn {
            from {
                transform: translateX(-400px);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }
        
        .panel-title {
            font-size: 16px;
            font-weight: bold;
            margin-bottom: 12px;
            color: #333;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .panel-title::before {
            content: "üìç";
            font-size: 18px;
        }
        
        /* Tabs */
        .tabs {
            display: flex;
            gap: 5px;
            margin-bottom: 12px;
            border-bottom: 2px solid #eee;
            flex-wrap: wrap;
        }
        
        .tab-btn {
            padding: 8px 12px;
            background: #f0f0f0;
            border: none;
            cursor: pointer;
            border-radius: 4px 4px 0 0;
            font-size: 12px;
            font-weight: 500;
            transition: all 0.2s;
            color: #666;
            white-space: nowrap;
        }
        
        .tab-btn:hover {
            background: #e0e0e0;
        }
        
        .tab-btn.active {
            background: #20c997;
            color: white;
        }
        
        .tab-content {
            display: none;
        }
        
        .tab-content.active {
            display: block;
        }
        
        .instruction {
            background: #f9f9f9;
            padding: 10px;
            border-left: 3px solid #20c997;
            margin-bottom: 12px;
            font-size: 12px;
            color: #555;
            line-height: 1.5;
        }
        
        #info {
            background: white;
            border: 1px solid #eee;
            border-radius: 4px;
            padding: 12px;
            min-height: 60px;
            margin-bottom: 10px;
        }
        
        .status-loading {
            color: #ff9800;
            font-weight: 500;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .status-loading::before {
            content: "‚è≥";
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }
        
        .route-info {
            background: #e3f2fd;
            padding: 10px;
            border-radius: 4px;
            margin: 8px 0;
            font-size: 12px;
            border-left: 3px solid #2196f3;
        }
        
        .route-info strong {
            color: #1976d2;
        }
        
        .distance {
            font-size: 14px;
            font-weight: bold;
            color: #1976d2;
        }
        
        .eta {
            font-size: 12px;
            color: #666;
            margin-top: 5px;
        }
        
        /* OSRM Route Label */
        .route-label {
            background: white;
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: 600;
            color: #1976d2;
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
            white-space: nowrap;
            display: flex;
            align-items: center;
            gap: 8px;
            animation: fadeInScale 0.5s ease-out;
        }
        
        @keyframes fadeInScale {
            from {
                opacity: 0;
                transform: scale(0.8);
            }
            to {
                opacity: 1;
                transform: scale(1);
            }
        }
        
        .route-label-icon {
            font-size: 14px;
        }
        
        .runner-info {
            background: #fff3e0;
            padding: 10px;
            border-radius: 4px;
            margin: 8px 0;
            border-left: 3px solid #ff9800;
            font-size: 12px;
        }
        
        .runner-name {
            font-weight: bold;
            color: #e65100;
            font-size: 13px;
        }
        
        .btn {
            background: #20c997;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            font-weight: 500;
            transition: background 0.2s;
            margin-top: 8px;
        }
        
        .btn:hover {
            background: #1aa179;
        }
        
        .btn:active {
            background: #0f7c54;
        }

        .btn-primary {
            background: #4c8cff;
            margin-top: 0;
        }

        .btn-primary:hover {
            background: #357ad8;
        }

        .status-badge {
            display: inline-block;
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 10px;
            font-weight: 600;
            text-transform: uppercase;
            margin-bottom: 8px;
        }

        .badge-pending {
            background: #fff3cd;
            color: #856404;
        }

        .badge-approved {
            background: #d4edda;
            color: #155724;
        }

        .badge-assigned {
            background: #cfe2ff;
            color: #084298;
        }

        .badge-rejected {
            background: #f8d7da;
            color: #721c24;
        }
        
        .coordinate-popup {
            background: white;
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 11px;
            font-weight: 500;
            box-shadow: 0 2px 6px rgba(0,0,0,0.2);
            pointer-events: auto;
            z-index: 2000 !important;
        }
        
        /* Scrollbar styling */
        #panel::-webkit-scrollbar {
            width: 6px;
        }
        
        #panel::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 3px;
        }
        
        #panel::-webkit-scrollbar-thumb {
            background: #c0c0c0;
            border-radius: 3px;
        }
        
        #panel::-webkit-scrollbar-thumb:hover {
            background: #a0a0a0;
        }
        
        .favorites-list {
            margin-top: 10px;
        }
        
        .favorite-item {
            background: #f5f5f5;
            padding: 8px;
            margin: 5px 0;
            border-radius: 3px;
            font-size: 12px;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: background 0.2s;
        }
        
        .favorite-item:hover {
            background: #e8e8e8;
        }
        
        .delete-btn {
            background: #ff5252;
            color: white;
            border: none;
            padding: 3px 8px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 11px;
        }
        
        .delete-btn:hover {
            background: #ff1744;
        }
    </style>
</head>
<body>
    <!-- Map Container -->
    <div id="map"></div>
    
    <!-- Control Panel -->
    <div id="panel">
        <div class="panel-title">Advanced Location Finder</div>
        
        <!-- Tabs -->
        <div class="tabs">
            <button class="tab-btn active" onclick="switchTab('route')">Route</button>
            <button class="tab-btn" onclick="switchTab('location')">Location</button>
            <button class="tab-btn" onclick="switchTab('delivery')">üì¶ Delivery</button>
            <button class="tab-btn" onclick="switchTab('favorites')">‚≠ê Favorites</button>
        </div>

        <!-- Delivery Tab (New) -->
        <div id="delivery" class="tab-content">
            <div class="instruction">
                üöÄ Quick delivery request setup<br>
                ‚è±Ô∏è Real-time order tracking<br>
                üèÉ Live runner updates
            </div>
            <button class="btn btn-primary" onclick="goToDeliveryPage()" style="width: 100%;">
                ‚ûï New Delivery Request
            </button>
            <div id="order-info"></div>
        </div>
        
        <!-- Route Tab -->
        <div id="route" class="tab-content active">
            <div class="instruction">
                üèÉ Nearest Runner Location<br>
                ‚è±Ô∏è Time to Reach You<br>
                üìè Distance in Kilometers
            </div>
            <div id="info">
                <div class="status-loading">Finding nearest runner...</div>
            </div>
        </div>
        
        <!-- Location Tab -->
        <div id="location" class="tab-content">
            <div class="instruction">Use GPS or manually set your location</div>
            <button class="btn" onclick="getCurrentLocation()" style="width: 100%;">üìç Get My GPS Location</button>
            <div id="location-display" style="margin-top: 10px;">
                <div class="status-loading">GPS Location: Not set</div>
            </div>
        </div>
        
        <!-- Favorites Tab -->
        <div id="favorites" class="tab-content">
            <div class="instruction">üìå Save and manage your favorite locations</div>
            <button class="btn" onclick="saveFavoriteLocation()" style="width: 100%;">üíæ Save Current Location</button>
            <div class="favorites-list" id="favorites-list">
                <div style="color: #999; font-size: 12px; text-align: center; padding: 20px 0;">No saved locations yet</div>
            </div>
        </div>
    </div>
    
    <!-- Leaflet JS -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.min.js"></script>
    
    <script>
        // ==================== DELIVERY ORDER STATE ====================
        let currentOrderId = null;
        let orderPollingInterval = null;

        function goToDeliveryPage() {
            window.location.href = '/request';
        }

        // ==================== DELIVERY ORDER TRACKING ====================
        // Global order data
        let orderData = null;
        let runnersData = [];
        
        // Get order ID from URL
        function getOrderFromURL() {
            const params = new URLSearchParams(window.location.search);
            return params.get('order_id');
        }
        
        // Load order from backend
        async function loadOrder(orderId) {
            try {
                const response = await fetch(`/api/order/${orderId}`);
                if (!response.ok) throw new Error('Order not found');
                
                const order = await response.json();
                console.log('‚úì Order loaded:', order);
                return order;
            } catch (error) {
                console.error('Error loading order:', error);
                return null;
            }
        }
        
        // Load runners from backend
        async function loadRunners() {
            try {
                const response = await fetch('/api/runners');
                if (!response.ok) throw new Error('Runners not found');
                
                const data = await response.json();
                // API returns array directly
                let runners = Array.isArray(data) ? data : (data.runners || []);
                
                // CRITICAL FIX: Normalize lon -> lng for consistency
                runners = runners.map(runner => ({
                    ...runner,
                    lng: runner.lng || runner.lon  // Support both lng and lon
                }));
                
                console.log('‚úì Runners loaded:', runners.length);
                console.log('‚úì First runner sample:', runners[0]);
                return runners;
            } catch (error) {
                console.error('Error loading runners:', error);
                return [];
            }
        }
        
        // Haversine distance formula
        function calculateHaversineDistance(lat1, lng1, lat2, lng2) {
            const R = 6371; // Earth radius in km
            const dLat = (lat2 - lat1) * Math.PI / 180;
            const dLng = (lng2 - lng1) * Math.PI / 180;
            
            const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
                      Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
                      Math.sin(dLng / 2) * Math.sin(dLng / 2);
            
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
            return R * c;
        }
        
        // Find nearest runner to delivery location
        function findNearestRunnerToDestination(deliveryLat, deliveryLng, runners) {
            console.log('üîç Finding nearest runner...', {deliveryLat, deliveryLng, runnersCount: runners?.length || 0});
            
            if (!runners || runners.length === 0) {
                console.error('‚ùå No runners available');
                return null;
            }
            
            let nearest = null;
            let minDistance = Infinity;
            
            for (const runner of runners) {
                // Normalize lng field (support both lng and lon)
                const runnerLng = runner.lng || runner.lon;
                
                // Validate runner data
                if (!runner || typeof runner.lat !== 'number' || typeof runnerLng !== 'number') {
                    console.warn('‚ö†Ô∏è Skipping invalid runner:', runner);
                    continue;
                }
                
                // Ensure runner has lng field for consistency
                runner.lng = runnerLng;
                
                const distance = calculateHaversineDistance(
                    deliveryLat, deliveryLng,
                    runner.lat, runner.lng
                );
                
                if (distance < minDistance) {
                    minDistance = distance;
                    nearest = runner;
                }
            }
            
            if (!nearest) {
                console.error('‚ùå No valid nearest runner found');
                return null;
            }
            
            const runnerName = nearest?.name || 'Unknown Runner';
            console.log('‚úì Nearest runner:', runnerName, 'Distance:', minDistance.toFixed(2), 'km');
            return nearest;
        }
        
        // Main order initialization
        async function initializeOrderTracking() {
            try {
                // STEP 1: Safely read order_id from URL
                const params = new URLSearchParams(window.location.search);
                const orderId = params.get('order_id');
                
                console.log('üîç Step 1: Order ID from URL:', orderId);
                
                if (!orderId) {
                    console.log('‚ÑπÔ∏è No order_id in URL - showing normal map');
                    return; // Exit gracefully - not an error
                }
                
                // Validate order_id format
                if (!orderId.startsWith('ORD-')) {
                    console.error('‚ùå Invalid order_id format:', orderId);
                    displayError('Invalid order ID format');
                    return;
                }
                
                console.log('üì¶ Step 2: Loading order data for', orderId);
                
                // STEP 2: Load order and runners (with timeout protection)
                let order, runners;
                try {
                    [order, runners] = await Promise.all([
                        loadOrder(orderId),
                        loadRunners()
                    ]);
                } catch (apiError) {
                    console.error('‚ùå API load failed:', apiError);
                    displayError('Failed to load order data');
                    return;
                }
                
                console.log('‚úì Step 3: Order loaded:', order ? order.order_id : 'NULL');
                console.log('‚úì Step 4: Runners loaded:', runners ? runners.length : 0);
                
                // STEP 3: Validate order data
                if (!order) {
                    console.error('‚ùå Order not found:', orderId);
                    displayError('Order not found');
                    return;
                }
                
                // CRITICAL: Validate coordinates exist
                if (typeof order.user_lat !== 'number' || typeof order.user_lng !== 'number') {
                    console.error('‚ùå Order missing coordinates:', order);
                    displayError('Order has invalid location data');
                    return;
                }
                
                // Validate coordinate ranges
                if (order.user_lat < -90 || order.user_lat > 90 || order.user_lng < -180 || order.user_lng > 180) {
                    console.error('‚ùå Order has out-of-range coordinates:', order.user_lat, order.user_lng);
                    displayError('Order has invalid coordinates');
                    return;
                }
                
                if (!runners || runners.length === 0) {
                    console.error('‚ùå No runners available');
                    displayError('No runners available');
                    return;
                }
                
                // STEP 4: Store globally
                orderData = order;
                runnersData = runners;
                console.log('‚úì Step 5: Order data stored globally');
                console.log('  Order location: (' + order.user_lat + ', ' + order.user_lng + ')');
                
                // STEP 5: Display order info
                try {
                    displayOrderInfo(order);
                    console.log('‚úì Step 6: Order info displayed');
                } catch (displayError) {
                    console.error('‚ö†Ô∏è Failed to display order info:', displayError);
                }
                
                // STEP 6: Check if approved
                if (order.status !== 'approved' && order.status !== 'assigned' && order.status !== 'completed') {
                    console.log('‚è≥ Step 7: Order status is', order.status, '- waiting for approval');
                    return; // Not an error - just waiting
                }
                
                console.log('‚úì Step 7: Order is approved, rendering route...');
                
                // STEP 7: Render route (can fail without breaking page)
                try {
                    await renderOrderRoute(order, runners);
                    console.log('‚úì Step 8: Route rendered successfully');
                } catch (routeError) {
                    console.error('‚ùå Failed to render route:', routeError);
                    displayError('Failed to render route: ' + routeError.message);
                    return;
                }
                
                // STEP 8: Start polling for updates
                try {
                    startOrderPolling(orderId);
                    console.log('‚úì Step 9: Polling started');
                } catch (pollError) {
                    console.error('‚ö†Ô∏è Failed to start polling:', pollError);
                }
                
                console.log('‚úÖ Order tracking initialization COMPLETE');
                
            } catch (error) {
                console.error('‚ùå CRITICAL ERROR in initializeOrderTracking():', error);
                console.error('Error stack:', error.stack);
                displayError('Failed to initialize: ' + error.message);
                // Don't throw - let map continue to work
            }
        }
        
        // Render route using OSRM
        async function renderOrderRoute(order, runners) {
            try {
                console.log('üó∫Ô∏è Starting route rendering...');
                console.log('Order Data:', order);
                console.log('Runners:', runners);
                
                // CRITICAL: Validate inputs
                if (!order || typeof order.user_lat !== 'number' || typeof order.user_lng !== 'number') {
                    throw new Error('Invalid order data - missing coordinates');
                }
                
                if (!runners || !Array.isArray(runners) || runners.length === 0) {
                    console.error('‚ùå No runners received from API');
                    throw new Error('No runners available');
                }
                
                // Validate map exists
                if (!map) {
                    throw new Error('Map not initialized');
                }
                
                // Destination is ALWAYS user delivery location
                const destinationLat = order.user_lat;
                const destinationLng = order.user_lng;
                
                console.log('üìç Destination:', destinationLat, destinationLng);
                
                // Find nearest runner
                const nearestRunner = findNearestRunnerToDestination(destinationLat, destinationLng, runners);
                console.log('Nearest Runner:', nearestRunner);
                console.log('Nearest Runner:', nearestRunner);
                
                if (!nearestRunner) {
                    console.error('‚ùå No nearest runner found');
                    throw new Error('No runners available');
                }
                
                // Validate runner coordinates
                if (typeof nearestRunner.lat !== 'number' || typeof nearestRunner.lng !== 'number') {
                    throw new Error('Nearest runner has invalid coordinates');
                }
                
                // START = nearest runner, END = delivery location
                const startLat = nearestRunner.lat;
                const startLng = nearestRunner.lng;
                const endLat = destinationLat;
                const endLng = destinationLng;
                
                console.log('üöÄ Calling OSRM API...');
                console.log('  START:', startLat, startLng, '(' + nearestRunner.name + ')');
                console.log('  END:', endLat, endLng);
                
                // Call OSRM for real road routing
                const routeData = await fetchRouteFromOSRM(startLat, startLng, endLat, endLng);
                
                console.log('‚úì OSRM response received:', routeData);
                
                if (!routeData || !routeData.success) {
                    throw new Error('OSRM routing failed: ' + (routeData?.error || 'Unknown error'));
                }
                
                // Validate route data
                if (!routeData.coordinates || !Array.isArray(routeData.coordinates)) {
                    throw new Error('OSRM returned invalid coordinates');
                }
                
                console.log('‚úì Route data valid:', routeData.distanceKm, 'km,', routeData.durationMinutes, 'min');
                console.log('‚úì Route has', routeData.coordinates.length, 'coordinate points');
                
                // Clear previous route
                clearRoute();
                console.log('‚úì Previous route cleared');
                
                // Draw route on map
                drawOSRMRoute(routeData, nearestRunner, order);
                console.log('‚úì Route drawn on map');
                
                // Center map on route
                try {
                    map.setView([destinationLat, destinationLng], 14);
                    console.log('‚úì Map centered on delivery location');
                } catch (viewError) {
                    console.error('‚ö†Ô∏è Failed to center map:', viewError);
                }
                
                // Update order info with real distance/time
                updateOrderInfoWithRoute(order, routeData, nearestRunner);
                console.log('‚úì Order info updated with route details');
                
            } catch (error) {
                console.error('‚ùå CRITICAL ERROR in renderOrderRoute():', error);
                console.error('Error stack:', error.stack);
                throw error; // Re-throw to be caught by caller
            }
        }
        
        // Clear previous route layers
        function clearRoute() {
            if (window.deliveryLine) {
                map.removeLayer(window.deliveryLine);
                window.deliveryLine = null;
            }
            if (window.routeLabelMarker) {
                map.removeLayer(window.routeLabelMarker);
                window.routeLabelMarker = null;
            }
            if (window.userDeliveryMarker) {
                map.removeLayer(window.userDeliveryMarker);
                window.userDeliveryMarker = null;
            }
            if (window.runnerDeliveryMarker) {
                map.removeLayer(window.runnerDeliveryMarker);
                window.runnerDeliveryMarker = null;
            }
        }
        
        // Draw OSRM route on map
        function drawOSRMRoute(routeData, runner, order) {
            try {
                console.log('üé® Drawing route on map...');
                
                // Validate inputs
                if (!map) {
                    throw new Error('Map not initialized');
                }
                
                if (!routeData || !routeData.coordinates || !Array.isArray(routeData.coordinates)) {
                    throw new Error('Invalid route data');
                }
                
                if (!runner || typeof runner.lat !== 'number' || typeof runner.lng !== 'number') {
                    throw new Error('Invalid runner data');
                }
                
                if (!order || typeof order.user_lat !== 'number' || typeof order.user_lng !== 'number') {
                    throw new Error('Invalid order data');
                }
                
                // Convert GeoJSON [lng, lat] to Leaflet [lat, lng]
                const leafletCoords = routeData.coordinates.map(coord => {
                    if (!Array.isArray(coord) || coord.length < 2) {
                        throw new Error('Invalid coordinate in route');
                    }
                    return [coord[1], coord[0]];
                });
                
                console.log('‚úì Converted', leafletCoords.length, 'coordinates');
                
                // Draw polyline
                window.deliveryLine = L.polyline(leafletCoords, {
                    color: '#4c8cff',
                    weight: 3,
                    opacity: 0.8,
                    lineCap: 'round',
                    lineJoin: 'round'
                }).addTo(map);
                console.log('‚úì Polyline drawn');
                
                // Add runner marker (red)
                window.runnerDeliveryMarker = L.circleMarker([runner.lat, runner.lng], {
                    radius: 10,
                    fillColor: '#ff6b6b',
                    color: '#c00000',
                    weight: 3,
                    opacity: 1,
                    fillOpacity: 0.8
                }).addTo(map);
                window.runnerDeliveryMarker.bindPopup(`üèÉ ${runner.name}`);
                console.log('‚úì Runner marker added');
                
                // Add delivery marker (blue)
                window.userDeliveryMarker = L.circleMarker([order.user_lat, order.user_lng], {
                    radius: 10,
                    fillColor: '#4c8cff',
                    color: '#1755a8',
                    weight: 3,
                    opacity: 1,
                    fillOpacity: 0.8
                }).addTo(map);
                window.userDeliveryMarker.bindPopup('üìç Delivery Location');
                console.log('‚úì Delivery marker added');
                
                // Calculate midpoint for label
                const midIdx = Math.floor(leafletCoords.length / 2);
                const midpoint = leafletCoords[midIdx];
                
                // Create label
                const labelHtml = `
                    <div class="route-label">
                        <span class="route-label-icon">üìç</span>
                        <span>${routeData.distanceKm} km ‚Ä¢ ${routeData.durationMinutes} min</span>
                    </div>
                `;
                
                window.routeLabelMarker = L.marker(midpoint, {
                    icon: L.divIcon({
                        html: labelHtml,
                        className: '',
                        iconSize: null,
                        iconAnchor: null
                    })
                }).addTo(map);
                console.log('‚úì Route label added');
                
                // Fit map to route
                const group = new L.featureGroup([window.userDeliveryMarker, window.runnerDeliveryMarker]);
                map.fitBounds(group.getBounds().pad(0.1));
                console.log('‚úì Map bounds fitted to route');
                
            } catch (error) {
                console.error('‚ùå Failed to draw route:', error);
                throw error; // Re-throw to be caught by caller
            }
        }
        
        // Display order info
        function displayOrderInfo(order) {
            const orderDiv = document.getElementById('info'); // Target visible div in Route tab
            
            if (!orderDiv) {
                console.error('‚ùå Cannot find info div');
                return;
            }
            
            const statusMessages = {
                'pending': '‚è≥ Waiting for admin approval...',
                'approved': '‚úì Order approved! Calculating route...',
                'assigned': 'üèÉ Runner en route to you!',
                'completed': '‚úì Delivery completed!',
                'rejected': '‚úï Order was rejected'
            };
            
            let html = `
                <div class="status-badge badge-${order.status}">${order.status.toUpperCase()}</div>
                <div class="route-info">
                    <strong>Order:</strong> ${order.order_id}<br>
                    <strong>Status:</strong> ${statusMessages[order.status] || order.status}
                </div>
            `;
            
            orderDiv.innerHTML = html;
            console.log('‚úì Order info displayed in info div');
        }
        
        // Update order info with route details
        function updateOrderInfoWithRoute(order, routeData, runner) {
            console.log('üìä Updating order info with route...', {order, routeData, runner});
            
            const orderDiv = document.getElementById('info'); // Target visible div in Route tab
            
            if (!orderDiv) {
                console.error('‚ùå Cannot find info div');
                return;
            }
            
            // Validate inputs
            if (!order) {
                console.error('‚ùå Order data is null');
                displayError('Order data missing');
                return;
            }
            
            if (!routeData) {
                console.error('‚ùå Route data is null');
                displayError('Route data missing');
                return;
            }
            
            if (!runner) {
                console.error('‚ùå Runner data is null');
                displayError('No runner assigned');
                return;
            }
            
            const statusMessages = {
                'pending': '‚è≥ Waiting for admin approval...',
                'approved': '‚úì Order approved! Runner assigned...',
                'assigned': 'üèÉ Runner en route to you!',
                'completed': '‚úì Delivery completed!',
                'rejected': '‚úï Order was rejected'
            };
            
            // Safely access runner properties
            const runnerName = runner?.name || 'Unknown Runner';
            const distanceKm = routeData?.distanceKm || 'N/A';
            const durationMin = routeData?.durationMinutes || 'N/A';
            
            let html = `
                <div class="status-badge badge-${order.status}">${order.status.toUpperCase()}</div>
                <div class="route-info">
                    <strong>Order:</strong> ${order.order_id}<br>
                    <strong>Status:</strong> ${statusMessages[order.status] || order.status}<br>
                    <strong>Runner:</strong> ${runnerName}<br>
                    <strong>Distance:</strong> <span class="distance">${distanceKm} km</span><br>
                    <strong>ETA:</strong> ${durationMin} min
                </div>
            `;
            
            orderDiv.innerHTML = html;
            console.log('‚úì Route info displayed:', distanceKm, 'km,', durationMin, 'min');
        }
        
        // Display error
        function displayError(message) {
            const orderDiv = document.getElementById('info'); // Target visible div in Route tab
            
            if (!orderDiv) {
                console.error('‚ùå Cannot find info div');
                return;
            }
            
            orderDiv.innerHTML = `<div class="status-loading">‚ùå ${message}</div>`;
            console.error('‚ùå Error displayed:', message);
        }
        
        // Start polling for order updates
        function startOrderPolling(orderId) {
            if (orderPollingInterval) return; // Already polling
            
            orderPollingInterval = setInterval(async () => {
                const order = await loadOrder(orderId);
                if (order && orderData) {
                    // Check if status changed
                    if (order.status !== orderData.status) {
                        console.log('Status changed:', orderData.status, '->', order.status);
                        orderData = order;
                        displayOrderInfo(order);
                        
                        // Re-render route if approved
                        if (order.status === 'approved' || order.status === 'assigned') {
                            await renderOrderRoute(order, runnersData);
                        }
                    }
                }
            }, 2000);
        }

        // ==================== OSRM ROUTING ====================
        async function fetchRouteFromOSRM(startLat, startLng, endLat, endLng) {
            try {
                const url = `https://router.project-osrm.org/route/v1/driving/${startLng},${startLat};${endLng},${endLat}?overview=full&geometries=geojson`;
                
                console.log('OSRM URL:', url);
                
                const response = await fetch(url);
                if (!response.ok) throw new Error(`OSRM Error: ${response.status}`);
                
                const data = await response.json();
                
                if (data.routes && data.routes.length > 0) {
                    const route = data.routes[0];
                    console.log('‚úì OSRM route received:', route.distance, 'm,', route.duration, 's');
                    return {
                        coordinates: route.geometry.coordinates, // GeoJSON format [lng, lat]
                        distanceMeters: route.distance,
                        distanceKm: (route.distance / 1000).toFixed(2),
                        durationSeconds: route.duration,
                        durationMinutes: Math.round(route.duration / 60),
                        success: true
                    };
                }
                
                return { success: false, error: 'No routes found' };
            } catch (error) {
                console.error('OSRM Error:', error);
                return { success: false, error: error.message };
            }
        }
        // Legacy updateDeliveryMap removed - now using renderOrderRoute

        // ==================== STATE ====================
        let map = null;
        let userMarker = null;
        let runnerMarkers = [];
        let routePolyline = null;
        let routeLabelMarker = null;
        let bikeMarker = null;
        let bikeProgress = Math.random() * 0.2; // Random start along the route
        let bikeActive = true;
        let clickTooltip = null;
        let destinationMarker = null;

        
        // Popular Tirupati locations
        const locations = {
            tirupatirailwaystation: { 
                name: 'Tirupati Railway Station Area',
                lat: 13.6150, 
                lng: 79.4050 
            },
            tirupaticentralmarket: { 
                name: 'Tirupati Central Market',
                lat: 13.6300, 
                lng: 79.4200 
            }
        };
        
        // State - will be populated from order data
        const state = {
            userLocation: { lat: 13.6150, lng: 79.4050 },  // Default center
            userLocationName: 'Map Center',
            selectedLocation: null,
            nearestRunner: null,
            runners: [],
            savedLocations: [],
            lastClickCoordinates: null,
            currentDistanceKm: null,
            currentTimeMin: null
        };
        
        // ==================== MAP INITIALIZATION ====================
        async function initializeMap() {
            try {
                console.log('üìç Initializing map...');
                
                // STEP 1: Create map FIRST - this must succeed
                try {
                    map = L.map('map', {
                        center: [13.6150, 79.4050], // Safe default center
                        zoom: 14,
                        zoomControl: true,
                        attributionControl: true,
                        dragging: true,
                        tap: true
                    });
                    
                    console.log('‚úì Map instance created');
                    
                    // Add tile layer
                    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                        attribution: '¬© OpenStreetMap contributors',
                        maxZoom: 19,
                        minZoom: 1
                    }).addTo(map);
                    
                    console.log('‚úì Tile layer added - map is visible');
                    
                } catch (mapError) {
                    console.error('‚ùå CRITICAL: Cannot create map:', mapError);
                    displayError('Failed to initialize map');
                    return; // Stop here - can't continue without map
                }
                
                // STEP 2: Set up event handlers (safe operation)
                try {
                    setupMapEventHandlers();
                    console.log('‚úì Event handlers registered');
                } catch (handlerError) {
                    console.error('‚ö†Ô∏è Event handler error (non-critical):', handlerError);
                }
                
                // STEP 3: Try to load order tracking (can fail safely)
                try {
                    await initializeOrderTracking();
                    console.log('‚úì Order tracking initialized');
                } catch (orderError) {
                    console.error('‚ö†Ô∏è Order tracking failed (map still works):', orderError);
                    // Map is still functional even if order tracking fails
                }
                
                console.log('‚úÖ Map initialization complete');
                
            } catch (error) {
                console.error('‚ùå Unexpected error in initializeMap():', error);
                // Even if everything fails, don't crash the entire page
            }
        }
        
        // ==================== MARKERS & LAYERS ====================
        function addUserMarker() {
            if (userMarker) userMarker.remove();
            
            userMarker = L.circleMarker([state.userLocation.lat, state.userLocation.lng], {
                radius: 8,
                fillColor: '#4285f4',
                color: '#1e40af',
                weight: 2,
                opacity: 1,
                fillOpacity: 0.8
            }).addTo(map);
            
            userMarker.bindPopup('üìç Your Location');
        }
        
        function addRunnerMarkers() {
            // Remove old markers
            runnerMarkers.forEach(marker => marker.remove());
            runnerMarkers = [];
            
            // Only show nearest runner marker
            if (state.nearestRunner) {
                const runner = state.nearestRunner;
                const marker = L.circleMarker([runner.lat, runner.lng], {
                    radius: 8,
                    fillColor: '#f44336',
                    color: '#c62828',
                    weight: 2,
                    opacity: 1,
                    fillOpacity: 0.9
                }).addTo(map);
                
                marker.bindPopup(`üèÉ <b>${runner.name}</b><br>Speed: ${runner.speed} km/h`);
                runnerMarkers.push(marker);
            }
        }
        
        // ==================== ROUTE CALCULATION ====================
        function calculateDistance(lat1, lng1, lat2, lng2) {
            const R = 6371; // Earth radius in km
            const dLat = (lat2 - lat1) * Math.PI / 180;
            const dLng = (lng2 - lng1) * Math.PI / 180;
            const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                     Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
                     Math.sin(dLng/2) * Math.sin(dLng/2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
            return R * c;
        }
        
        function findNearestRunner() {
            console.log('üîç Finding nearest runner for user location...', {runners: state.runners.length});
            
            if (!state.runners || state.runners.length === 0) {
                console.error('‚ùå No runners available');
                state.nearestRunner = null;
                updateRouteDisplay();
                return;
            }
            
            let nearest = null;
            let minDistance = Infinity;
            
            state.runners.forEach(runner => {
                // Normalize lng field (support both lng and lon)
                const runnerLng = runner.lng || runner.lon;
                
                // Validate runner data
                if (!runner || typeof runner.lat !== 'number' || typeof runnerLng !== 'number') {
                    console.warn('‚ö†Ô∏è Skipping invalid runner:', runner);
                    return;
                }
                
                // Ensure runner has lng field for consistency
                runner.lng = runnerLng;
                
                const distance = calculateDistance(
                    state.userLocation.lat,
                    state.userLocation.lng,
                    runner.lat,
                    runner.lng
                );
                
                if (distance < minDistance) {
                    minDistance = distance;
                    nearest = { ...runner, distance };
                }
            });
            
            if (!nearest) {
                console.error('‚ùå No valid nearest runner found');
            } else {
                const runnerName = nearest?.name || 'Unknown Runner';
                console.log('‚úì Nearest runner found:', runnerName);
            }
            
            state.nearestRunner = nearest;
            updateRouteDisplay();
        }
        
        function updateRouteDisplay() {
            const infoEl = document.getElementById('info');
            
            if (!state.nearestRunner) {
                infoEl.innerHTML = '<div class="status-loading">Finding nearest runner...</div>';
                return;
            }
            
            const runner = state.nearestRunner;
            const bikePos = bikeActive
                ? getBikePosition(runner.lat, runner.lng, state.userLocation.lat, state.userLocation.lng, bikeProgress)
                : null;
            const distanceKm = bikePos
                ? calculateDistance(state.userLocation.lat, state.userLocation.lng, bikePos.lat, bikePos.lng)
                : runner.distance;
            const time = Math.max(0, Math.round((distanceKm / runner.speed) * 60)); // minutes
            state.currentDistanceKm = distanceKm;
            state.currentTimeMin = time;
            
            infoEl.innerHTML = `
                <div class="runner-info">
                    <div class="runner-name">üèÉ ${runner.name}</div>
                    
                    <!-- Runner Location -->
                    <div style="margin-top: 12px; padding: 10px; background: #ffe8e8; border-radius: 4px;">
                        <div style="font-size: 11px; color: #666; margin-bottom: 4px;"><strong>üèÉ Runner Location (Starting Point):</strong></div>
                        <div style="font-size: 12px; font-weight: bold; color: #c62828; margin-bottom: 6px;">${runner.locationName || 'Tirupati Central'}</div>
                        <div style="font-size: 11px; font-family: monospace; color: #c62828;">
                            Latitude: ${runner.lat.toFixed(6)}<br>
                            Longitude: ${runner.lng.toFixed(6)}
                        </div>
                    </div>
                    
                    <!-- Your Location -->
                    <div style="margin-top: 10px; padding: 10px; background: #e3f2fd; border-radius: 4px;">
                        <div style="font-size: 11px; color: #666; margin-bottom: 4px;"><strong>üìç Your Location (Destination):</strong></div>
                        <div style="font-size: 12px; font-weight: bold; color: #1e40af; margin-bottom: 6px;">${state.userLocationName || 'Your Location'}</div>
                        <div style="font-size: 11px; font-family: monospace; color: #1e40af;">
                            Latitude: ${state.userLocation.lat.toFixed(6)}<br>
                            Longitude: ${state.userLocation.lng.toFixed(6)}
                        </div>
                    </div>
                    
                    <!-- Distance & Time -->
                    <div style="margin-top: 10px; padding: 12px; background: #f0f0f0; border-radius: 4px; border-left: 4px solid #20c997;">
                        <div style="margin: 5px 0; font-size: 12px;">
                            <strong>üìè Distance:</strong> <span style="color: #20c997; font-weight: bold;">${distanceKm.toFixed(2)} km</span>
                        </div>
                        <div style="margin: 5px 0; font-size: 12px;">
                            <strong>‚è±Ô∏è Time to Reach You:</strong> <span style="color: #20c997; font-weight: bold;">${time} minutes</span>
                        </div>
                        <div style="margin: 5px 0; font-size: 12px;">
                            <strong>üöÄ Runner Speed:</strong> <span style="color: #666;">${runner.speed} km/h</span>
                        </div>
                    </div>
                </div>
            `;
            
            // Draw route polyline with distance/time label
            drawRoute(state.userLocation.lat, state.userLocation.lng, runner.lat, runner.lng);
        }

        function getBikePosition(startLat, startLng, endLat, endLng, progress) {
            return {
                lat: startLat + (endLat - startLat) * progress,
                lng: startLng + (endLng - startLng) * progress
            };
        }
        
        function drawRoute(lat1, lng1, lat2, lng2) {
            if (routePolyline) routePolyline.remove();
            if (routeLabelMarker) routeLabelMarker.remove();
            if (bikeMarker) bikeMarker.remove();
            
            // Route line from RUNNER (lat2, lng2) to USER (lat1, lng1)
            // Starting point: Runner | Ending point: User
            routePolyline = L.polyline([
                [lat2, lng2],  // Start: Runner location
                [lat1, lng1]   // End: User location
            ], {
                color: '#2196f3',
                weight: 3,
                opacity: 0.7,
                dashArray: '5, 5'
            }).addTo(map);
            
            // Add distance label on the polyline
            if (state.nearestRunner) {
                const midLat = (lat1 + lat2) / 2;
                const midLng = (lng1 + lng2) / 2;
                const distance = (state.currentDistanceKm ?? state.nearestRunner.distance).toFixed(2);
                const time = Math.max(0, Math.round(((state.currentDistanceKm ?? state.nearestRunner.distance) / state.nearestRunner.speed) * 60));
                
                // Create a label marker
                const labelMarker = L.divIcon({
                    html: `<div style="background: white; padding: 4px 8px; border-radius: 3px; font-size: 11px; font-weight: bold; border: 1px solid #2196f3; box-shadow: 0 1px 3px rgba(0,0,0,0.2);">
                        ${distance}km, ${time}min
                    </div>`,
                    className: '',
                    iconSize: null
                });
                
                routeLabelMarker = L.marker([midLat, midLng], { icon: labelMarker }).addTo(map);
            }

            updateBikeMarker(lat1, lng1, lat2, lng2);
        }

        function updateBikeMarker(lat1, lng1, lat2, lng2) {
            if (!bikeActive) return;

            const startLat = lat2;
            const startLng = lng2;
            const endLat = lat1;
            const endLng = lng1;

            const bikePos = getBikePosition(startLat, startLng, endLat, endLng, bikeProgress);
            const bikeLat = bikePos.lat;
            const bikeLng = bikePos.lng;

            const bikeIcon = L.divIcon({
                html: '<div style="font-size: 18px; line-height: 1;">üö¥‚Äç‚ôÇÔ∏è</div>',
                className: '',
                iconSize: [18, 18],
                iconAnchor: [9, 9]
            });

            bikeMarker = L.marker([bikeLat, bikeLng], { icon: bikeIcon, interactive: false }).addTo(map);
        }
        
        // ==================== EVENT HANDLERS ====================
        function setupMapEventHandlers() {
            if (!map) {
                console.error('‚ùå Cannot set up event handlers - map not initialized');
                return;
            }
            
            try {
                map.on('click', (e) => {
                    const { lat, lng } = e.latlng;
                    state.lastClickCoordinates = { lat, lng };

                    // Restart bike movement from runner start on click
                    bikeProgress = 0;
                    bikeActive = true;
                    
                    // Show tooltip
                    showCoordinateTooltip(lat, lng);
                    console.log(`üìç Clicked: ${lat.toFixed(6)}, ${lng.toFixed(6)}`);
                });
                
                console.log('‚úì Map click handler registered');
            } catch (error) {
                console.error('‚ùå Failed to set up event handlers:', error);
            }
        }
        
        function showCoordinateTooltip(lat, lng) {
            const html = `<div class="coordinate-popup">
                üìç ${lat.toFixed(6)}, ${lng.toFixed(6)}<br>
                <small>Click to copy</small>
            </div>`;
            
            const tooltip = L.popup({
                autoClose: true,
                closeButton: false,
                className: 'coordinate-popup'
            })
            .setLatLng([lat, lng])
            .setContent(html)
            .openOn(map);
        }
        
        // Legacy updateRunners removed - now loading from API
        
        // ==================== LOCATION FUNCTIONS ====================
        function getCurrentLocation() {
            if ('geolocation' in navigator) {
                document.getElementById('location-display').innerHTML = 
                    '<div class="status-loading">Getting your location...</div>';
                
                navigator.geolocation.getCurrentPosition(
                    (position) => {
                        const { latitude, longitude } = position.coords;
                        state.userLocation = { lat: latitude, lng: longitude };
                        
                        addUserMarker();
                        map.setView([latitude, longitude], 15);
                        
                        document.getElementById('location-display').innerHTML = `
                            <div class="route-info">
                                <strong>üìç GPS Location:</strong><br>
                                ${latitude.toFixed(6)}, ${longitude.toFixed(6)}
                            </div>
                        `;
                        
                        findNearestRunner();
                    },
                    (error) => {
                        document.getElementById('location-display').innerHTML = 
                            '<div style="color: #f44336; font-weight: 500;">‚ùå Location access denied</div>';
                        console.error('Geolocation error:', error);
                    }
                );
            }
        }
        
        function saveFavoriteLocation() {
            if (!state.selectedLocation && !state.userLocation) {
                alert('Set a location first');
                return;
            }
            
            const location = state.selectedLocation || state.userLocation;
            const name = prompt('Location name:', `Location ${state.savedLocations.length + 1}`);
            
            if (name) {
                state.savedLocations.push({
                    name,
                    lat: location.lat,
                    lng: location.lng
                });
                
                refreshFavoritesList();
            }
        }
        
        function refreshFavoritesList() {
            const list = document.getElementById('favorites-list');
            
            if (state.savedLocations.length === 0) {
                list.innerHTML = '<div style="color: #999; font-size: 12px; text-align: center; padding: 20px 0;">No saved locations yet</div>';
                return;
            }
            
            list.innerHTML = state.savedLocations.map((loc, idx) => `
                <div class="favorite-item">
                    <span onclick="goToFavorite(${idx})">üìç ${loc.name}</span>
                    <button class="delete-btn" onclick="deleteFavorite(${idx})">Delete</button>
                </div>
            `).join('');
        }
        
        function goToFavorite(idx) {
            const loc = state.savedLocations[idx];
            state.selectedLocation = { lat: loc.lat, lng: loc.lng };
            map.setView([loc.lat, loc.lng], 15);
        }
        
        function deleteFavorite(idx) {
            state.savedLocations.splice(idx, 1);
            refreshFavoritesList();
        }
        
        // ==================== TAB MANAGEMENT ====================
        function switchTab(tabName) {
            // Hide all tabs
            document.querySelectorAll('.tab-content').forEach(tab => {
                tab.classList.remove('active');
            });
            
            document.querySelectorAll('.tab-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            
            // Show selected tab
            document.getElementById(tabName).classList.add('active');
            event.target.classList.add('active');
        }
        
        // ==================== INITIALIZATION ====================
        async function start() {
            console.log('üìã Starting application...');
            
            // Wait for Leaflet to be loaded
            if (typeof L === 'undefined') {
                console.error('‚ùå Leaflet library not loaded');
                setTimeout(start, 100);
                return;
            }
            
            console.log('‚úì Leaflet library available');
            await initializeMap();
        }
        
        // Start when DOM is ready
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', start);
        } else {
            setTimeout(start, 100);
        }
    </script>
</body>
</html>
